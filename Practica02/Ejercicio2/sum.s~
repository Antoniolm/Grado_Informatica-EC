.section .data
	.macro linea
		#.int  1,2,10, 1,2,0b10, 1,2,0x10
		.int -1,-1,-1,1,-1,-1,-1,-1,-1
		#.int -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
		#.int 1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2,1,-2
		#.int 1,2,-3,-4,1,2,-3,-4,1,2,-3,-4,1,2,-3,-4,1,2,-3,-4,1,2,-3,-4,1,2,-3,-4,1,2,-3,-4

	.endm
lista: .irpc i,1
		linea
       .endr

longlista:
	.int (.-lista)/4
resultado:
	.quad 0x01234567

formato:
	.ascii "suma = %lld = %llx hex\n\0"

.section .text
main: .global main

	mov $lista,    %ebx
	mov longlista, %ecx
	call suma
	mov %edi, resultado+4	#Obtenemos la suma acumulada
	mov %esi, resultado	#Y la introducimos en la variable resultado
	
	pushl resultado+4	#Realizamos los push necesarias para realizar un printf con
	pushl resultado		#Valores de 64bits
	pushl resultado+4
	pushl resultado
	push $formato
	call printf		#Realizamos la impresi√≥n del resultados
	add $20,%esp

	mov $1, %eax		#Ponemos los valores necesarias para realizar la salida del programa
	mov $0, %ebx

	int $0x80		#Realizamos la salida del programa


suma:
	push %edx
	mov $0, %edx 	#mas   significativo sin acumular
	mov $0, %eax 	#menos significativo sin acumular
	mov $0, %ebp 	#contador del bucle
	mov $0, %edi 	#mas   significativo acumulado
	mov $0, %esi 	#menos significativo acumulado

bucle:
	mov (%ebx,%ebp,4),%eax	#Movemos el elemento actual de la lista
	cdq  			#Realizamos la instruccion cdq y nos introduce los valores
	add %eax,%esi		#resultantes en eax y edx
	adc %edx,%edi		#Acumulamos ambos valores
	
	inc %ebp
	cmp %ebp,%ecx
	jne bucle

	pop %edx
	ret

